\documentclass[letterpaper, 11pt]{article}

\usepackage{tikz, listings, comment}
\usepackage[fleqn]{amsmath}
\usepackage[margin=1in]{geometry}
\usepackage{fancyhdr, hyperref, pdfpages}
\usepackage{xcolor}
\usepackage{float} % Add this to your preamble if not already included

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

% Disable page numbers
\pagestyle{empty}

%Basic Variables (Modify as required per homework)
\def\class{CompEn 462}
\def\homeworkNumber{Final Project}
\def\date{05.08.2025}
\def\professor{Mark Mahon}

% Define a custom style for listings
\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   % Set background color for the code block
    commentstyle=\color{codegreen},       % Set color for comments
    keywordstyle=\color{magenta},         % Set color for keywords
    numberstyle=\tiny\color{codegray},    % Set style for line numbers
    stringstyle=\color{codepurple},       % Set color for strings
    basicstyle=\ttfamily\footnotesize,    % Set basic style for the code
    breakatwhitespace=false,              % Do not break lines at whitespace
    breaklines=true,                      % Allow breaking of lines
    captionpos=b,                         % Set caption position to bottom
    keepspaces=true,                      % Keep spaces in text
    %numbers=left,                         % Display line numbers on the left
    numbersep=5pt,                        % Set distance between line numbers and code
    showspaces=false,                     % Do not show spaces
    showstringspaces=false,               % Do not show spaces in strings
    showtabs=false,                       % Do not show tabs
    tabsize=2                             % Set tab size to 2 spaces
}

\lstset{style=mystyle}

%Code to generate new page for problem
\newcounter{problemId}
\stepcounter{problemId}
\def\newproblem{\clearpage\newpage\noindent{Problem~\arabic{problemId}\stepcounter{problemId}}\hfill\par}

%Custom Section Header Command
\newcommand{\secHeader}[1]{\vspace{2mm} \noindent \textbf{#1:}\vspace{-4mm}}

\begin{document}
%Title page
\hfill
\newline
Name: Justin Ngo
\\PSU ID: jvn5439
\\Professor: \professor
\\Class: \class
\\Date: \date
\\Project : Wireless MAC Address Spoofing Detection System Using ESP32

%---------------------ABSTRACT---------------------
\newpage
\secHeader{Abstract}
\vspace{5mm}

The purpose of this project is to use an ESP32 microcontroller to create a device that passively detects wireless connections to an access point and logs the MAC addresses and RSSI of the various
connections that are made. The device operates in two modes: learning and monitoring. When the device detects that there are no known connections in the known\_connections\_file, it will enter
learning mode and begin logging the MAC addresses and corresponding RSSI of the connections that are made for the next 2 minutes and 30 seconds. Assuming that these connections are "normal" connections,
the device will save these MAC addresses and their corresponding RSSI values to the known\_connections\_file and use that as a sort of whitelist of valid MAC addresses. 
After the learning period, the device will enter monitoring mode and try to determine if the MAC address of incoming traffic is a spoofed MAC address or not by comparing the RSSI of any new connections
to the RSSI of other connections that were made recently. \\ 


%---------------------OUTLINE---------------------
\newpage
\secHeader{Outline}
\vspace{5mm}

The main idea behind this project was just to experiment with the ESP32 microcontroller and see if I could get it to detect wireless connections made to the access point in my apartment living room.


\secHeader{Tools and Libraries}
\vspace{5mm}
\begin{enumerate}
    \item Windows Command Prompt: command prompt was used during development to pull the MAC address and IP of the access point that I was trying to target, and during testing to 
    ping the access point to generate traffic for the device to detect.
    \item Arduino Nano ESP32 Microcontroller: this was the main hardware part used in the project. I selected it primarily because it was easy to get and I have a little experience with using other 
    Arduino microcontrollers.
    \item Arduino IDE: all the code was done in the Arduino IDE. I selected this IDE because I have prior experience with it from another class and remember it being fairly intuitive to use
    \item SPIFFS Library: the SPIFFS library is what allowed the ESP32 to create a JSON file on its onboard flash memory. I found out about it while looking for a way to save the packet information
    to a file for the device to reference later.
    \item Wifi Library: the Wifi library allowed the ESP32 to connect to the same wifi network as my computer. I'm not sure that it was entirely necessary to go through with adding the ESP32 to the 
    network but did so anyway to ensure that it was properly scanning the network for connections.
    \item ESP32 Wifi Library: I used this library to set the ESP32 in promiscuous mode. This library is core to the device's functionality as it's what allows the ESP32 to detect the 
    MAC addresses and RSSI of the connections that are made to the access point.
    \item ArduinoJson Library: I used this to maintain the JSON file which stored the known connections that the device learned during its learning phase.
\end{enumerate}


\newpage
\secHeader{Major Code Components}
\vspace{5mm}

\begin{figure}[H] % Use [H] to force the figure to stay here
    \centering
    \includegraphics[width=0.8\textwidth]{Diagram.png}
    \caption{System Diagram}
    \label{fig:SystemDiagram}
\end{figure}

The figure above shows a very general overview of how the system works. The ESP32 detects packets in promiscuous mode which are then processed by the Packet Sniffer function. The MAC 
Filter removes packets to or from the other access points on the network and also ignores packets sent to FF:FF:FF:FF:FF:FF, which is the broadcast address to prevent the device from
flooding the storage with unnecessary packets. Depending on what mode the device is currently operating in, the device will either save the packet information to the known\_connections\_file 
or compare the RSSI of the incoming packet to the RSSI of the other recently received packets to try and determine if it's coming from a spoofed MAC address.

\newpage
\begin{lstlisting}[language=C++, caption=Packet Sniffer and MAC Filter, label=lst:main_code]
// Ignored MACs
const DeviceInfo ignoredMACs[] = {
    { { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF }, 0, 0, 0 }  // Broadcast address
};
// Function to check if a MAC address should be ignored
bool isIgnoredMAC(const uint8_t *mac) {
    // Check against ignored MACs list
    for (const auto &ignored : ignoredMACs) {
    if (memcmp(mac, ignored.mac, 6) == 0) {
        return true;
    }
    }

    // Make sure not to ignore the Host AP's MAC address
    if (mac[0] == 0x84 && mac[1] == 0x23 && mac[2] == 0x88 && mac[3] == 0x7B && mac[4] == 0x90 && mac[5] == 0xA0) { 
    return false;
    } 
    //Ignore the MAC addresses of other APs on network
    else if (mac[0] == 0x84 && mac[1] == 0x23 && mac[2] == 0x88) {
    return true;
    }
    return false;
}

// Packet sniffer function
void sniffer(void *buf, wifi_promiscuous_pkt_type_t type) {
  wifi_promiscuous_pkt_t *packet = (wifi_promiscuous_pkt_t *)buf;
  uint8_t *srcMAC = &packet->payload[10];
  int rssi = packet->rx_ctrl.rssi;

  // Skip ignored MACs
  if (isIgnoredMAC(srcMAC)) return;
  
  updateObservedDevices(srcMAC, rssi);
  if (learningMode) {
    // Print during active window
      const char *pktType = (type == WIFI_PKT_MGMT) ? "MGMT" : "DATA";
      Serial.printf("%s - MAC: %s RSSI: %d dBm\n", pktType, macToString(srcMAC).c_str(), rssi);
  } else {
    checkForSpoofing(srcMAC, rssi);
  }
} 
\end{lstlisting}
The packet sniffer is one of the main functions, and is responsible for detecting the packets that are sent to the access point. After detecting a packet, the function checks if the MAC address
is in the ignored MACs list by calling isIgnoredMAC. If it is, the function will ignore the packet and move on to the next one. If it isn't, the function will call the updateObservedDevices 
function to update the list of recently observed devices. If the device is in learning mode, the function will also print the MAC address and RSSI of the packet to the serial monitor for the 
user to see. If the device is in monitoring mode, the function will call checkForSpoofing to try and determine if the MAC address is being spoofed.

\newpage
\begin{lstlisting}[language=C++, caption=Spoof Detection, label=lst:spoof detector]
// Check for MAC spoofing
void checkForSpoofing(const uint8_t *mac, int rssi) {
  unsigned long currentTime = millis();

  // Check if MAC matches AP's MAC
  if (memcmp(mac, AP_BSSID, 6) == 0) {
    Serial.println("\nALERT: Device using AP's MAC address detected!");
    return;
  }

  // Check against known devices
  for (const auto &known : knownDevices) {
    if (memcmp(mac, known.mac, 6) == 0) {
      if (abs(rssi - known.avgRSSI) > RSSI_VARIATION_THRESHOLD) {
        Serial.printf("\nALERT: Known device %s shows abnormal RSSI change! Current RSSI: %d dBm, Known Avg RSSI: %d dBm", macToString(mac).c_str(), rssi, known.avgRSSI);
        break; // Stop after the first match
      }
      return;
    }
  }

  // Check for MAC randomization
  for (auto &observed : observedDevices) {
    if (abs(rssi - observed.avgRSSI) < RANDOM_MAC_RSSI && memcmp(mac, observed.mac, 6) != 0 && (currentTime - observed.lastSeen) < TIME_WINDOW) {
      if (currentTime - observed.lastAlertTime > TIME_WINDOW) { // Cooldown check
        Serial.printf("\nALERT: Potential MAC randomization detected!");
        Serial.printf("\nCurrent: %s, Previous: %s\n", macToString(mac).c_str(), macToString(observed.mac).c_str());
        observed.lastAlertTime = currentTime; // Update last alert time
        break; // Stop after the first match
      }
    }
  }
}
\end{lstlisting}
The checkForSpoofing function is the other primary function and is what runs the main logic to determine if the MAC address is being spoofed or not. It checks for 3 main criteria:
\begin{enumerate}
    \item If the MAC address matches the MAC address of the access point
    \item If the RSSI from a known device falls outside of the variation threshold (set to 20 dBm)
    \item If the RSSI from an unknown device compared to another recently observed device is within the random MAC RSSI threshold (set to 10 dBm) 
\end{enumerate}
If any of these criteria are met, the function will print an alert to the serial monitor. The logic behind the third criteria is that if the RSSI of an unknown device is within a 10 dBm range
of another recently observed device, it could be a sign that the device is using a randomized MAC address. The TIME\_WINDOW variable determines how long the observed devices are "kept in memory" 
and is supposed to resets the cooldown period for the alert. However, in testing, it seems that certain devices still manage to trigger the alert more than once within that time period, as shown below 

\begin{lstlisting}[language=C++, caption=Serial Output for Spoof Detection, label=lst:spoof detector serial output]
  23:43:38.834 -> ALERT: Potential MAC randomization detected!
  23:43:38.872 -> Current: F6:04:3A:AB:86:9A, Previous: C0:E7:BF:5E:40:C6
  23:43:38.872 -> 
  23:43:38.872 -> ALERT: Potential MAC randomization detected!
  23:43:38.872 -> Current: F6:89:C7:EE:36:30, Previous: 42:86:27:F0:01:AE
\end{lstlisting}

\vspace{5mm}
\noindent\textbf{Assumptions}

One of the core assumptions that I made on this project was that I could isolate the traffic being sent to the access point that I wanted to target. I assumed that by filtering out the MAC addresses
of the other access points on the network (since it's a shared network for the entire apartment complex), I would be able to get a good idea of the traffic that was being sent to my access point.
I unfortunately don't know if this assumption was correct and am unsure of whether I successfully isolate the traffic that was being picked up by the ESP32. This assumption is also why I can't come to
any definitive conclusions about how effective the device is at detecting spoofed MAC addresses. 


%---------------------RESULTS---------------------
\newpage
\secHeader{Testing}
\vspace{5mm}
The easiest functionality to test was checking known devices for abnormal RSSI fluctuations. In order to test the device, I ran the program on the ESP32 and let it sit by my computer for the duration 
while pinging the access point using Windows Command Prompt to make sure that my PC was generating enough traffic to get a good baseline of the RSSI. I also had spotify running in the background to 
generate some additional traffic just to ensure that I was getting accurate data. Once the learning period was over, I moved my laptop between the ESP32 and my computer, 
and then shrouded the ESP32 with paper and aluminum foil to introduce some interference and see if the device would correctly detect the RSSI change.





\begin{lstlisting}[language=bash, caption=Testing Known Devices for Abnormal RSSI Values, label=lst:testing]
WINDOWS COMMAND PROMPT:
  Connection-specific DNS Suffix  . :
  Description . . . . . . . . : Realtek 8723DE Wireless LAN 802.11n PCI-E NIC
  Physical Address. . . . . . : 1C-BF-C0-A1-DB-15
  DHCP Enabled. . . . . . . . : Yes
  Autoconfiguration Enabled . : Yes
  IPv4 Address. . . . . . . . : 172.16.201.160(Preferred)
  Subnet Mask . . . . . . . . : 255.255.255.0
  Default Gateway . . . . . . : fe80::a55:31ff:feeb:57e5%13
                                172.16.201.1
  DHCP Server . . . . . . . . : 172.16.201.1
  DHCPv6 IAID . . . . . . . . : 203210688
  DHCPv6 Client DUID. . . . . : 00-01-00-01-2D-C7-85-A3-A4-BB-6D-B0-6C-C8
  DNS Servers . . . . . . . . : 8.8.8.8
  NetBIOS over Tcpip. . . . . : Enabled

ping 172.16.201.1

Pinging 172.16.201.1 with 32 bytes of data:
Reply from 172.16.201.1: bytes=32 time=5ms TTL=64
Reply from 172.16.201.1: bytes=32 time=6ms TTL=64
Reply from 172.16.201.1: bytes=32 time=8ms TTL=64
Reply from 172.16.201.1: bytes=32 time=5ms TTL=64

Ping statistics for 172.16.201.1:
  Packets: Sent = 4, Received = 4, Lost = 0 (0% loss),
Approximate round trip times in milli-seconds:
  Minimum = 5ms, Maximum = 8ms, Average = 6ms

ARDUINO SERIAL MONITOR:
15:18:16.316 -> Learning complete. Saved 149 known devices.
15:18:16.316 -> Switching to monitoring mode...
15:18:16.316 -> Your MAC address: 1C:BF:C0:A1:DB:15 was detected during learning mode. RSSI: -29 dBm
15:20:23.365 -> ALERT: Known device 1C:BF:C0:A1:DB:15 shows abnormal RSSI change! Current RSSI: -55 dBm, Known Avg RSSI: -29 dBm
\end{lstlisting}

\secHeader{Results}
\vspace{5mm}

The device does work and is capable of sniffing packets and logging the corresponding MAC addresses and RSSI values. The device is also capable of saving the known connections to a JSON file
and loading them back into memory when the device is restarted, either by pushing the button or uploading new code with the IDE. However, I'm not sure how effective the device is at detecting when a 
MAC address is being spoofed. 
\end{document}